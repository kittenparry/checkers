#!/usr/bin/env python3

import sys
import curses

# colours taken from https://godoc.org/github.com/whitedevops/colors
class COL:
	ResetAll = "\033[0m"

	Bold = "\033[1m"
	Dim = "\033[2m"
	Underlined = "\033[4m"
	Blink = "\033[5m"
	Reverse = "\033[7m"
	Hidden = "\033[8m"

	ResetBold = "\033[21m"
	ResetDim = "\033[22m"
	ResetUnderlined = "\033[24m"
	ResetBlink = "\033[25m"
	ResetReverse = "\033[27m"
	ResetHidden = "\033[28m"

	Default = "\033[39m"
	Black = "\033[30m"
	Red = "\033[31m"
	Green = "\033[32m"
	Yellow = "\033[33m"
	Blue = "\033[34m"
	Magenta = "\033[35m"
	Cyan = "\033[36m"
	LightGray = "\033[37m"
	DarkGray = "\033[90m"
	LightRed = "\033[91m"
	LightGreen = "\033[92m"
	LightYellow = "\033[93m"
	LightBlue = "\033[94m"
	LightMagenta = "\033[95m"
	LightCyan = "\033[96m"
	White = "\033[97m"

	BackgroundDefault = "\033[49m"
	BackgroundBlack = "\033[40m"
	BackgroundRed = "\033[41m"
	BackgroundGreen = "\033[42m"
	BackgroundYellow = "\033[43m"
	BackgroundBlue = "\033[44m"
	BackgroundMagenta = "\033[45m"
	BackgroundCyan = "\033[46m"
	BackgroundLightGray = "\033[47m"
	BackgroundDarkGray = "\033[100m"
	BackgroundLightRed = "\033[101m"
	BackgroundLightGreen = "\033[102m"
	BackgroundLightYellow = "\033[103m"
	BackgroundLightBlue = "\033[104m"
	BackgroundLightMagenta = "\033[105m"
	BackgroundLightCyan = "\033[106m"
	BackgroundWhite = "\033[107m"

def start():
	# FIXME: should probably reduce the game board to 4x8
	# and fill the rest of unplayable ground visually on runtime
	# or maybe replace 0s with -1s in unplayable squares

	# hand-made for now
	# 1s and 3s are player-1's discs and kings
	# 2s and 4s are player-2's discs and kings
	game_board = [
		[2, 2, 2, 2],
		[2, 2, 2, 2],
		[2, 2, 2, 2],
		[0, 0, 0, 0],
		[0, 0, 0, 0],
		[1, 1, 1, 1],
		[1, 1, 1, 1],
		[1, 1, 1, 1],
	]

	# loop through it to draw the game board
	# different colours depending on player discs
	# dark bg for inactive squares for visibility
	# for y in range(8):
	# 	for i, x in enumerate(game_board[y]):
	# 		# to alternate colour orders between rows
	# 		if y % 2 == 0:
	# 			i += 1
	# 		if i % 2 == 0:
	# 			bg = COL.BackgroundLightGray
	# 			fg = COL.Yellow
	# 		else:
	# 			bg = COL.BackgroundDefault
	# 			if x == 2 or x == 4:
	# 				fg = COL.LightRed
	# 			elif x == 1 or x == 3:
	# 				fg = COL.LightMagenta
	# 		sys.stdout.write('%s%s%s%s' % (bg, fg, str(x), COL.ResetAll))
	# 	sys.stdout.write('\n')
	# sys.stdout.flush()

# source: https://stackoverflow.com/a/10694430/4085881
	stdscr = curses.initscr()
	curses.cbreak()
	stdscr.keypad(1)

	# starting and current player
	player = 2
	stdscr.addstr(0, 10, 'Hit \'q\' to quit')
	stdscr.refresh()


	pos_x = 0
	pos_y = 0
	disc_selected = False
	key = ''
	while key != ord('q'):
		key = stdscr.getch()
		stdscr.addstr(2, 10, 'Turn: Player-%d' % player)
		for y in range(8):
			for i, x in enumerate(game_board[y]):
				if y % 2 == 0: # if border columns
					add = i * 2
				else: # else altering columns
					add = i * 2 + 1
				stdscr.addstr(add, y, str(x))
		stdscr.refresh()

		# TODO: maybe restrict the movement to discs?
		# but how do i know disc positions if i can't even tell what's under the cursor?
		# edit game_board on movement?
		# again, probably should use a 4x8 grid, maybe
		if key == curses.KEY_UP:
			# if 2nd row, move one up-left (diagonal)
			if pos_x == 1:
				pos_x -= 1
				pos_y -= 1
			# else move two up (vertical)
			else:
				pos_x = pos_x - 2 if pos_x - 2 > 0 else 0
		if key == curses.KEY_DOWN:
			# if 7th row, move one bottom-right (diagonal)
			if pos_x == 6:
				pos_x += 1
				pos_y += 1
			# else move two down (vertical)
			else:
				pos_x = pos_x + 2 if pos_x + 2 < 7 else 7
		if key == curses.KEY_LEFT:
			# don't do anything at 0, 0 or x, 0
			if (pos_x == 0 and pos_y == 0) or pos_y == 0:
				pass
			# if topmost row, move bottom-left (diagonal)
			elif pos_x == 0 and pos_y != 0:
				pos_x += 1
				pos_y -= 1
			# if bottommost row, move top-left (diagonal)
			elif pos_x == 7:
				pos_x -= 1
				pos_y -= 1
			# if odd rows, move bottom-left (diagonal)
			elif pos_x % 2 == 1:
				pos_x -= 1
				pos_y -= 1
			# if even rows, move top-left (diagonal)
			else:
				pos_x += 1
				pos_y -= 1
		if key == curses.KEY_RIGHT:
			# don't do anything at 1, 7 or x, 7
			if (pos_x == 1 and pos_y == 7) or pos_y == 7:
				pass
			# if topmost row, move bottom-right (diagonal)
			elif pos_x == 0 and pos_y != 7:
				pos_x += 1
				pos_y += 1
			# if odd rows, move bottom-right (diagonal)
			elif pos_x % 2 == 1:
				pos_x -= 1
				pos_y += 1
			# if even rows, move top-right (diagonal)
			else:
				pos_x += 1
				pos_y += 1

		if key == 10:
			# clear cursor's position of clutter, e.g. b'1' into 1
			# FIXME: could probably use another replace instead of split join by single quote
			current_tile = str(''.join(str(stdscr.instr(pos_x, pos_y, 1)).split('\'')).replace('b', ''))

			# check if player selected a tile
			for row in game_board:
				if 'x' in row:
					disc_selected = True

			# FIXME: actual game rules
			if disc_selected and current_tile == '0':
				stdscr.addstr(pos_x, pos_y, str(player))
				for n, row in enumerate(game_board):
					for i, x in enumerate(row):
						if x == 'x':
							# reset tile in board array
							game_board[n][i] = 0
							# set current tile to player's disc
							game_board[pos_y][get_res_x(pos_y, pos_x)] = player
							# temporarily draw onto tile where x was before re-draw
							stdscr.addstr(get_act_x(n, i), n, '0')
							disc_selected = False
							# change turn
							player = 2 if player == 1 else 1


			# if current tile is of player's disc
			# TODO: ability to deselect a disc
			# or deselect by selecting another one?
			if (current_tile == str(player)) and not disc_selected:
				# set current tile to an x mark in board array
				game_board[pos_y][get_res_x(pos_y, pos_x)] = 'x'
				# temporarily draw x on current tile until re-draw on cursor move
				stdscr.addstr(pos_x, pos_y, 'x')
			# notify that it is the opponent's turn when wrong disc is selected
			if (current_tile == str(1 if player == 2 else 2)) and not disc_selected:
				stdscr.addstr(4, 10, '!! Player-%d\'s turn' % player)
			else:
				stdscr.addstr(4, 10, '                    ')

		stdscr.move(pos_x, pos_y)

	curses.endwin()

def get_res_x(pos_y, pos_x):
	"""Return the second level array position of a given tile."""
	if pos_y % 2 == 0:
		res_x = int(pos_x / 2)
	else:
		res_x = int((pos_x - 1 if pos_x > 0 else 0) / 2)
	return res_x

def get_act_x(pos_y, pos_x):
	"""Do the reverse of above function. Array position into a tile position."""
	if pos_y % 2 == 0: # if border columns
		act_x = pos_x * 2
	else: # else altering columns
		act_x = pos_x * 2 + 1
	return act_x

if __name__ == '__main__':
	start()
