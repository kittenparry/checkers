#!/usr/bin/env python3

import sys
import curses

# colours taken from https://godoc.org/github.com/whitedevops/colors
class COL:
	ResetAll = "\033[0m"

	Bold = "\033[1m"
	Dim = "\033[2m"
	Underlined = "\033[4m"
	Blink = "\033[5m"
	Reverse = "\033[7m"
	Hidden = "\033[8m"

	ResetBold = "\033[21m"
	ResetDim = "\033[22m"
	ResetUnderlined = "\033[24m"
	ResetBlink = "\033[25m"
	ResetReverse = "\033[27m"
	ResetHidden = "\033[28m"

	Default = "\033[39m"
	Black = "\033[30m"
	Red = "\033[31m"
	Green = "\033[32m"
	Yellow = "\033[33m"
	Blue = "\033[34m"
	Magenta = "\033[35m"
	Cyan = "\033[36m"
	LightGray = "\033[37m"
	DarkGray = "\033[90m"
	LightRed = "\033[91m"
	LightGreen = "\033[92m"
	LightYellow = "\033[93m"
	LightBlue = "\033[94m"
	LightMagenta = "\033[95m"
	LightCyan = "\033[96m"
	White = "\033[97m"

	BackgroundDefault = "\033[49m"
	BackgroundBlack = "\033[40m"
	BackgroundRed = "\033[41m"
	BackgroundGreen = "\033[42m"
	BackgroundYellow = "\033[43m"
	BackgroundBlue = "\033[44m"
	BackgroundMagenta = "\033[45m"
	BackgroundCyan = "\033[46m"
	BackgroundLightGray = "\033[47m"
	BackgroundDarkGray = "\033[100m"
	BackgroundLightRed = "\033[101m"
	BackgroundLightGreen = "\033[102m"
	BackgroundLightYellow = "\033[103m"
	BackgroundLightBlue = "\033[104m"
	BackgroundLightMagenta = "\033[105m"
	BackgroundLightCyan = "\033[106m"
	BackgroundWhite = "\033[107m"

def start():
	# FIXME: should probably reduce the game board to 4x8
	# and fill the rest of unplayable ground visually on runtime
	# or maybe replace 0s with -1s in unplayable squares

	# hand-made for now
	# 1s and 3s are player-1's discs and kings
	# 2s and 4s are player-2's discs and kings
	game_board = [
		[2, 2, 2, 2],
		[2, 2, 2, 2],
		[2, 2, 2, 2],
		[0, 0, 0, 0],
		[0, 0, 0, 0],
		[1, 1, 1, 1],
		[1, 1, 1, 1],
		[1, 1, 1, 1],
	]

	# loop through it to draw the game board
	# different colours depending on player discs
	# dark bg for inactive squares for visibility
	# for y in range(8):
	# 	for i, x in enumerate(game_board[y]):
	# 		# to alternate colour orders between rows
	# 		if y % 2 == 0:
	# 			i += 1
	# 		if i % 2 == 0:
	# 			bg = COL.BackgroundLightGray
	# 			fg = COL.Yellow
	# 		else:
	# 			bg = COL.BackgroundDefault
	# 			if x == 2 or x == 4:
	# 				fg = COL.LightRed
	# 			elif x == 1 or x == 3:
	# 				fg = COL.LightMagenta
	# 		sys.stdout.write('%s%s%s%s' % (bg, fg, str(x), COL.ResetAll))
	# 	sys.stdout.write('\n')
	# sys.stdout.flush()

# source: https://stackoverflow.com/a/10694430/4085881
	stdscr = curses.initscr()
	curses.cbreak()
	stdscr.keypad(1)

	# starting and current player
	player = 2
	stdscr.addstr(0, 10, 'Hit \'q\' to quit')
	stdscr.addstr(1, 10, 'Press any key to start...')
	stdscr.addstr(3, 10, '----- --------')
	stdscr.refresh()


	# current tile position
	pos_x = 0
	pos_y = 0
	# selected disc x, y, and value (to preserve if king)
	sel_disc_x = -1
	sel_disc_y = -1
	sel_disc = ''
	disc_selected = False

	key = ''
	while key != ord('q'):
		key = stdscr.getch()
		stdscr.addstr(1, 10, '                         ')
		stdscr.addstr(2, 10, 'Turn: Player-%d' % player)
		stdscr.addstr(8, 10, 'sel:  %s%s   ' % (sel_disc_x, sel_disc_y))
		for y in range(8):
			for i, x in enumerate(game_board[y]):
				if y % 2 == 0: # if border columns
					add = i * 2
				else: # else altering columns
					add = i * 2 + 1
				stdscr.addstr(add, y, str(x))
		stdscr.refresh()

		# TODO: maybe restrict the movement to discs?
		# but how do i know disc positions if i can't even tell what's under the cursor?
		# edit game_board on movement?
		# again, probably should use a 4x8 grid, maybe
		if key == curses.KEY_UP:
			# if 2nd row, move one up-left (diagonal)
			if pos_x == 1:
				pos_x -= 1
				pos_y -= 1
			# else move two up (vertical)
			else:
				pos_x = pos_x - 2 if pos_x - 2 > 0 else 0
		if key == curses.KEY_DOWN:
			# if 7th row, move one bottom-right (diagonal)
			if pos_x == 6:
				pos_x += 1
				pos_y += 1
			# else move two down (vertical)
			else:
				pos_x = pos_x + 2 if pos_x + 2 < 7 else 7
		if key == curses.KEY_LEFT:
			# don't do anything at 0, 0 or x, 0
			if (pos_x == 0 and pos_y == 0) or pos_y == 0:
				pass
			# if topmost row, move bottom-left (diagonal)
			elif pos_x == 0 and pos_y != 0:
				pos_x += 1
				pos_y -= 1
			# if bottommost row, move top-left (diagonal)
			elif pos_x == 7:
				pos_x -= 1
				pos_y -= 1
			# if odd rows, move bottom-left (diagonal)
			elif pos_x % 2 == 1:
				pos_x -= 1
				pos_y -= 1
			# if even rows, move top-left (diagonal)
			else:
				pos_x += 1
				pos_y -= 1
		if key == curses.KEY_RIGHT:
			# don't do anything at 1, 7 or x, 7
			if (pos_x == 1 and pos_y == 7) or pos_y == 7:
				pass
			# if topmost row, move bottom-right (diagonal)
			elif pos_x == 0 and pos_y != 7:
				pos_x += 1
				pos_y += 1
			# if odd rows, move bottom-right (diagonal)
			elif pos_x % 2 == 1:
				pos_x -= 1
				pos_y += 1
			# if even rows, move top-right (diagonal)
			else:
				pos_x += 1
				pos_y += 1

		if key == 10:
			# clear cursor's position of clutter, e.g. b'1' into 1
			# FIXME: could probably use another replace instead of split join by single quote
			current_tile = str(''.join(str(stdscr.instr(pos_x, pos_y, 1)).split('\'')).replace('b', ''))

			# check if player selected a tile
			for row in game_board:
				if 'x' in row:
					disc_selected = True

			# deselect disc if one is selected by selecting it again
			if disc_selected and current_tile == 'x':
				disc_selected = False
				sel_disc_x = -1
				sel_disc_y = -1
				game_board[pos_y][get_res_x(pos_y, pos_x)] = player
				stdscr.addstr(pos_x, pos_y, sel_disc)
				sel_disc = ''

			# select another disc when one is already selected
			if disc_selected and (current_tile == str(player) or current_tile == str(player + 2)):
				game_board[sel_disc_y][get_res_x(sel_disc_y, sel_disc_x)] = int(sel_disc)
				stdscr.addstr(sel_disc_x, sel_disc_y, sel_disc)
				game_board[pos_y][get_res_x(pos_y, pos_x)] = 'x'
				sel_disc_x = pos_x
				sel_disc_y = pos_y
				sel_disc = current_tile
				stdscr.addstr(pos_x, pos_y, 'x')

			# FIXME: actual game rules
			if disc_selected and current_tile == '0':
				illegal_move = True
				diff_x = int((pos_x - sel_disc_x) / 2)
				diff_y = int((pos_y - sel_disc_y) / 2)
				opp_x, opp_y = calculate_opponent_pos(pos_x, pos_y, diff_x, diff_y)
				stdscr.addstr(7, 10, 'dif:  %s%s   ' % (diff_x, diff_y))
				stdscr.addstr(9, 10, 'opp:  %s%s   ' % (opp_x, opp_y))
				opponent_tile = str(''.join(str(stdscr.instr(opp_x, opp_y, 1)).split('\'')).replace('b', ''))
				opponent = str(1 if player == 2 else 2)

				# only allow movement one step further or behind opponent
				if diff_x == 0 and diff_y == 0:
					illegal_move = False
				elif opponent_tile == opponent or opponent_tile == str(int(opponent) + 2):
					illegal_move = False
					game_board[opp_y][get_res_x(opp_y, opp_x)] = 0
					stdscr.addstr(opp_x, opp_y, '0')
				else:
					illegal_move = True

				if illegal_move:
					stdscr.addstr(5, 10, '!! Illegal move')
				else:
					stdscr.addstr(5, 10, '               ')
					# movement after if action is legal
					for n, row in enumerate(game_board):
						for i, x in enumerate(row):
							if x == 'x':
								# reset tile in board array
								game_board[n][i] = 0
								# set current tile to player's disc
								res_player = int(sel_disc)
								stdscr.addstr(6, 10, '                              ')
								# check if end of the board and disc isn't already a king
								if is_at_end(pos_x, pos_y, player) and res_player < 3:
									res_player += 2
									stdscr.addstr(6, 10, '!! Player-%d crowned a king' % player)
								game_board[pos_y][get_res_x(pos_y, pos_x)] = res_player
								stdscr.addstr(pos_x, pos_y, str(res_player))
								# temporarily draw onto tile where x was before re-draw
								stdscr.addstr(get_act_x(n, i), n, '0')
								disc_selected = False
								sel_disc_x = -1
								sel_disc_y = -1
								sel_disc = ''
								# change turn
								player = 2 if player == 1 else 1


			# if current tile is of player's disc
			# TODO: ability to deselect a disc
			# or deselect by selecting another one?
			if (current_tile == str(player) or current_tile == str(player + 2)) and not disc_selected:
				# set current tile to an x mark in board array
				game_board[pos_y][get_res_x(pos_y, pos_x)] = 'x'
				sel_disc_x = pos_x
				sel_disc_y = pos_y
				sel_disc = current_tile
				# temporarily draw x on current tile until re-draw on cursor move
				stdscr.addstr(pos_x, pos_y, 'x')

			# notify that it is the opponent's turn when wrong disc is selected
			if (current_tile == str(1 if player == 2 else 2) or current_tile == str(3 if player == 2 else 4)) and not disc_selected:
				stdscr.addstr(4, 10, '!! Player-%d\'s turn' % player)
			else:
				stdscr.addstr(4, 10, '                    ')

		stdscr.move(pos_x, pos_y)

	curses.endwin()

def get_res_x(pos_y, pos_x):
	"""Return the second level array position of a given tile."""
	if pos_y % 2 == 0:
		res_x = int(pos_x / 2)
	else:
		res_x = int((pos_x - 1 if pos_x > 0 else 0) / 2)
	return res_x

def get_act_x(pos_y, pos_x):
	"""Do the reverse of above function. Array position into a tile position."""
	if pos_y % 2 == 0: # if border columns
		act_x = pos_x * 2
	else: # else altering columns
		act_x = pos_x * 2 + 1
	return act_x

def calculate_opponent_pos(new_x, new_y, diff_x, diff_y):
	"""Calculate opponent's position by movement difference.
	
	args:
	new_x, new_y -- moved position of player
	diff_x, diff_y -- difference between starting and ending position
	"""
	opp_x = new_x - diff_x
	opp_y = new_y - diff_y
	return opp_x, opp_y

def is_at_end(pos_x, pos_y, player):
	"""Determine if player has reached end of the board and earned a promotion."""
	if player == 1:
		if (pos_y == 0 and pos_x % 2 == 0) or (pos_y == 1 and pos_x % 2 == 1):
			return True
		return False
	else:
		if (pos_y == 6 and pos_x % 2 == 0) or (pos_y == 7 and pos_x % 2 == 1):
			return True
		return False


if __name__ == '__main__':
	start()
